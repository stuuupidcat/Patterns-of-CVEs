#[inline]
unsafe fn realloc(
    &mut self,
    ptr: NonNull<u8>,
    layout: Layout,
    new_size: usize,
) -> Result<NonNull<u8>, alloc::AllocErr> {
    let old_size = layout.size();

    if old_size == 0 {
        return self.alloc(layout);
    }

    if new_size <= old_size {
        if self.is_last_allocation(ptr)
            // Only reclaim the excess space (which requires a copy) if it
            // is worth it: we are actually going to recover "enough" space
            // and we can do a non-overlapping copy.
            && new_size <= old_size / 2
        {
            let delta = old_size - new_size;
            let footer = self.current_chunk_footer.get();
            let footer = footer.as_ref();
            footer
                .ptr
                .set(NonNull::new_unchecked(footer.ptr.get().as_ptr().add(delta)));
            let new_ptr = footer.ptr.get();
            // NB: we know it is non-overlapping because of the size check
            // in the `if` condition.
            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), new_size);
            return Ok(new_ptr);
        } else {
            return Ok(ptr);
        }
    }

    if self.is_last_allocation(ptr) {
        // Try to allocate the delta size within this same block so we can
        // reuse the currently allocated space.
        let delta = new_size - old_size;
        if let Some(p) =
            self.try_alloc_layout_fast(layout_from_size_align(delta, layout.align()))
        {
            ptr::copy(ptr.as_ptr(), p.as_ptr(), new_size);
            return Ok(p);
        }
    }

    // Fallback: do a fresh allocation and copy the existing data into it.
    let new_layout = layout_from_size_align(new_size, layout.align());
    let new_ptr = self.alloc_layout(new_layout);
    ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), old_size);
    Ok(new_ptr)
}
